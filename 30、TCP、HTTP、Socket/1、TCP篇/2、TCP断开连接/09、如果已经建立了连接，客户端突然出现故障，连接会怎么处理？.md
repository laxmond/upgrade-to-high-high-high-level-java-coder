## 如果已经建立了连接，客户端突然出现故障，连接会怎么处理？



#### 客户端突然崩溃的情况

- 客户端进程崩溃

  进程崩溃后操作系统在回收进程资源的时候，会发送 FIN 报文，后续的挥手过程也都是在内核完成，然后两端关闭！

- 客户端发生宕机或者断电

  发生这种情况的时候，内核都已经关闭了，服务端永远就接受不到来自客户端的FIN报文，如果服务端一直不会发送数据给客户端，那么服务端是永远无法感知到客户端宕机这个事件的，也就是服务端的 TCP 连接将一直处于 `ESTABLISH` 状态，占用着系统资源

  为了避免这种情况，TCP 搞了个**保活机制**。这个机制的原理是这样的：

  

  定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。

  在 Linux 内核可以有对应的参数可以设置保活时间、保活探测的次数、保活探测的时间间隔，以下都为默认值：

  ```shell
  net.ipv4.tcp_keepalive_time=7200
  net.ipv4.tcp_keepalive_intvl=75  
  net.ipv4.tcp_keepalive_probes=9
  ```

  tcp_keepalive_time=7200：表示保活时间是 7200 秒（2小时），也就 2 小时内如果没有任何连接相关的活动，则会启动保活机制tcp_keepalive_intvl=75：表示每次检测间隔 75 秒；

  tcp_keepalive_probes=9：表示检测 9 次无响应，认为对方是不可达的，从而中断本次的连接。

  

  也就是说在 Linux 系统中，最少需要经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接。





#### TCP保活机制时间太长，我们用什么取代呢？

我们可以自己在应用层实现一个心跳机制。

比如，web 服务软件一般都会提供 `keepalive_timeout` 参数，用来指定 HTTP 长连接的超时时间。如果设置了 HTTP 长连接的超时时间是 60 秒，web 服务软件就会**启动一个定时器**，如果客户端在完成一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，**定时器的时间一到，就会触发回调函数来释放该连接。**



